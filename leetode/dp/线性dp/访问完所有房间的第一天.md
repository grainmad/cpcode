## 题目

[1997. 访问完所有房间的第一天](https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/)

---

你需要访问 `n` 个房间，房间从 `0` 到 `n - 1` 编号。同时，每一天都有一个日期编号，从 `0` 开始，依天数递增。你每天都会访问一个房间。

最开始的第 `0` 天，你访问 `0` 号房间。给你一个长度为 `n` 且 **下标从 0 开始** 的数组 `nextVisit` 。在接下来的几天中，你访问房间的 **次序** 将根据下面的 **规则** 决定：

-   假设某一天，你访问 `i` 号房间。
-   如果算上本次访问，访问 `i` 号房间的次数为 **奇数** ，那么 **第二天** 需要访问 `nextVisit[i]` 所指定的房间，其中 `0 <= nextVisit[i] <= i` 。
-   如果算上本次访问，访问 `i` 号房间的次数为 **偶数** ，那么 **第二天** 需要访问 `(i + 1) mod n` 号房间。

请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 `10^9 + 7` 取余后的结果。

  

**示例 1：**

```txt
输入：nextVisit = [0,0]
输出：2
解释：
- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。
  下一天你需要访问房间的编号是 nextVisit[0] = 0
- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。
  下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1
- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。
```

**示例 2：**

```txt
输入：nextVisit = [0,0,2]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。
第 6 天是你访问完所有房间的第一天。
```

**示例 3：**

```txt
输入：nextVisit = [0,1,2,0]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。
第 6 天是你访问完所有房间的第一天。
```
  

**提示：**

-   `n == nextVisit.length`
-   `2 <= n <= 10^5`
-   `0 <= nextVisit[i] <= i`

  

## 解题

### 方法一：

#### 思路


注意到`nextVisit[i]<=i`，当我们从i移动到i+1位置时，访问i是偶数次，所以首次访问i会移动到`nextVisit[i]`位置。接下来从`nextVisit[i]`到i中途经过的每个位置j（除了i）都是偶数次。都需要回访到`nextVisits[j]`。

定义$f_i$为从i到i+1位置需要的步数。

显然$f_i = 2 + \sum \limits_{j=nextVisit[i]}^{i-1}f_j$，`i`位置经过了两次。

我们只需要求得$\sum \limits_{i=0}^{n-2}f_i$即可。在最后访问了n-1位置一次，但是由于第一天访问是从0开始，所以只需累加前n-2个位置的$f_i$即可。

#### 代码

```cpp
class Solution {
public:
    int firstDayBeenInAllRooms(vector<int>& nextVisit) {
        int n = nextVisit.size();
        long M = 1e9+7;
        vector<long> p(n);
        for (int i=0; i<n-1; i++) {
            p[i+1] = (p[i] + (p[i]-p[nextVisit[i]]+M+2)%M)%M;
        }
        return p[n-1];
    }
};
```
