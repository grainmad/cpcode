## 题目

[100097. 合法分组的最少组数](https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/description/)

---

给你一个长度为 `n` 下标从 **0** 开始的整数数组 `nums` 。

我们想将下标进行分组，使得 `[0, n - 1]` 内所有下标 `i` 都 **恰好** 被分到其中一组。

如果以下条件成立，我们说这个分组方案是合法的：

-   对于每个组 `g` ，同一组内所有下标在 `nums` 中对应的数值都相等。
-   对于任意两个组 `g1` 和 `g2` ，两个组中 **下标数量** 的 **差值不超过** `1` 。

请你返回一个整数，表示得到一个合法分组方案的 **最少** 组数。

  

**示例 1：**

```txt
输入：nums = [3,2,3,2,3]
输出：2
解释：一个得到 2 个分组的方案如下，中括号内的数字都是下标：
组 1 -> [0,2,4]
组 2 -> [1,3]
所有下标都只属于一个组。
组 1 中，nums[0] == nums[2] == nums[4] ，所有下标对应的数值都相等。
组 2 中，nums[1] == nums[3] ，所有下标对应的数值都相等。
组 1 中下标数目为 3 ，组 2 中下标数目为 2 。
两者之差不超过 1 。
无法得到一个小于 2 组的答案，因为如果只有 1 组，组内所有下标对应的数值都要相等。
所以答案为 2 。
```

**示例 2：**

```txt
输入：nums = [10,10,10,3,1,1]
输出：4
解释：一个得到 2 个分组的方案如下，中括号内的数字都是下标：
组 1 -> [0]
组 2 -> [1,2]
组 3 -> [3]
组 4 -> [4,5]
分组方案满足题目要求的两个条件。
无法得到一个小于 4 组的答案。
所以答案为 4 。
```
  

**提示：**

-   `1 <= nums.length <= 10^5`
-   `1 <= nums[i] <= 10^9`

  

## 题解

### 方法一：

#### 思路

统计每种数字的频次。总频次之和为$10^5$。

找到最小的频次mn。

每一组的大小要么为x，要么为x+1。我们可以枚举这个x，枚举范围在1到mn

当确定x后，遍历每种数字的频次，将其拆分为多个x与x+1。拆分的方式有多种，可以枚举x的出现次数，然后计算x+1的出现次数。然后在众多拆分方式中选择拆分组数最少的一种，每种数字最少拆分数累加起来得到tans。

每个x中维护tans最小值作为答案。

由于最小频次为mn，没有其他频次比mn小。我们不妨设mn为$\sqrt n$，共计有$\sqrt n$种数字，这是最坏情况。其复杂仍然为$O(n)$

假设共有k种不同的数，第i种数的频次是$p_i$

我们知道$p_1 + p_2 + \cdots + p_k = n$

枚举在1到mn的x作为组大小，确定最少组数所需时间复杂度为$O(p_1/x)+O(p_2/x)+\cdots+O(p_k/x) = O((p_1 + p_2 + \cdots + p_k)/x) = O(n/x)$
总时间复杂度为$O(n/1+n/2+\cdots+n/mn) = O(nln(mn))$

#### 代码

```C++
class Solution {
public:
    using ll = long long;
    int minGroupsForValidAssignment(vector<int>& nums) {
        map<int,int> mp;
        for (auto i:nums) mp[i]++;
        vector<int> a;
        ll mn = 1e9, ans = 1e9;
        for (auto [i,j]:mp) a.push_back(j), mn = min(mn, 0LL+j);
        while (mn) {
            ll tans = 0;
            for (int i:a) {
                ll c = 1e9;
                for (int j=0; j<=i/mn; j++) {
                    if ((i-j*mn)%(mn+1) == 0) {
                        c = min(c, j+(i-j*mn)/(mn+1));
                    }
                }
                tans += c;
            }
            ans = min(ans, tans);
            mn--;
        }
        return ans;
    }
};

```
