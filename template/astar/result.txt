=============================== case 1 =====================================
struct Node {
    int x, y, dis;
    int g() const { return dis; }
    double h() const { return (abs(x - ex) + abs(y - ey)) * 1.000; }
    bool operator<(const Node& o) const {
        return g() + h() > o.g() + o.h();
    }
    Node(int _x, int _y, int _dis) : x(_x), y(_y), dis(_dis) {}
};
评估函数 f(x) = g(x) + h(x)
g(x) x节点到起点的距离，
h(x) x节点到目标的曼哈顿距离。

block.txt
........................................
........................................
......OOOOOOOOOOOOO.....................
.....OSOOOOOOOOOOOOO....................
.....O*CCCOOOOOCCCCO....................
.....O*CCCCCCCCOOOOOOOOOOO..............
.....O*CCCCCCCCCCCCCCCCCCC#.............
.....O*CCOCCCCCCCCCCCCCCCC#.............
.....O**COCCCCCCCCCCCCCCCC#.............
.....OO*COCCCCCCCCCCCCCCCC#.............
......O*COCCCCCCCCCCCCCCCC#.............
......O*C##################.............
......O*CCOOOOOOO.......................
......O*CCCCCCCCCOOOOOOOOOOOOOO.........
......O*CCCCCCCCCCCCCCCCCCCCCCCO........
......O**************CCCCCCCCCCO........
......OCCCCCCOOCOCCO***********E........
.......OOOOOO..O.OO.OOOOOOOOOOO.........
........................................
........................................
empty.txt
........................................
........................................
......OOO...............................
.....OSOOO..............................
.....O**CCOOOOO.........................
.....OO*******CO........................
.....OOOCCCCC**COOOOOOOOOOOOOO..........
.....OOOOOCCCC*******CCCCCCCCCOO........
.....OOCCOCCCCOOOOCC*CCCCCCCCCCCO.......
......OOCOCCCCCCCCCO*CCCCCCCCCOO........
.......OCOCOCOOOOCCO**CCCCCCOO..........
.......OCCOOCCO..OOOC*OOOOOOOOOO........
.......OCCCCOCCO....O*********CCO.......
.......OCOOOOCO......OOOOOOOO**CO.......
........O....O...............O*CO.......
.............................O*O........
.............................O*E........
..............................O.........
........................................
........................................

=============================== case 2 =====================================

struct Node {
    int x, y, dis;
    int g() const { return dis; }
    int h() const { return (abs(x - ex) + abs(y - ey)); }
    bool operator<(const Node& o) const {
        return g() + h() > o.g() + o.h();
    }
    Node(int _x, int _y, int _dis) : x(_x), y(_y), dis(_dis) {}
};
评估函数 f(x) = g(x) + h(x)
g(x) x节点到起点的距离，
h(x) x节点到目标的曼哈顿距离(浮点数)。
block.txt
........................................
........................................
......OOOOOOOOOOOOO.....................
.....OSOOOOOOOOOOOOO....................
.....O*CCCOOOOOCCCCO....................
.....O*CCCCCCCCOOOOOOOOOOO..............
.....O*CCCCCCCCCCCCCCCCCCC#.............
.....O*CCOCCCCCCCCCCCCCCCC#.............
.....O**COCCCCCCCCCCCCCCCC#.............
.....OO*COCCCCCCCCCCCCCCCC#.............
......O*COCCCCCCCCCCCCCCCC#.............
......O*C##################.............
......O*CCOOOOOOO.......................
......O*CCCCCCCCCOOOOOOOOOOOOOO.........
......O*CCCCCCCCCCCCCCCCCCCCCCCO........
......O**************CCCCCCCCCCO........
......OCCCCCCOOCOCCO***********E........
.......OOOOOO..O.OO.OOOOOOOOOOO.........
........................................
........................................

empty.txt
........................................
........................................
......OOO...............................
.....OSOOO..............................
.....O**CCOOOOO.........................
.....OO*******CO........................
.....OOOCCCCC**COOOOOOOOOOOOOO..........
.....OOOOOCCCC*******CCCCCCCCCOO........
.....OOCCOCCCCOOOOCC*CCCCCCCCCCCO.......
......OOCOCCCCCCCCCO*CCCCCCCCCOO........
.......OCOCOCOOOOCCO**CCCCCCOO..........
.......OCCOOCCO..OOOC*OOOOOOOOOO........
.......OCCCCOCCO....O*********CCO.......
.......OCOOOOCO......OOOOOOOO**CO.......
........O....O...............O*CO.......
.............................O*O........
.............................O*E........
..............................O.........
........................................
........................................

=============================== case 3 =====================================
struct Node {
    int x, y, dis;
    int g() const { return dis; }
    double h() const { return (abs(x - ex) + abs(y - ey)) * 1.0001; }
    bool operator<(const Node& o) const {
        return g() + h() > o.g() + o.h();
    }
    Node(int _x, int _y, int _dis) : x(_x), y(_y), dis(_dis) {}
};
评估函数 f(x) = g(x) + h(x)
g(x) x节点到起点的距离，
h(x) x节点到目标的曼哈顿距离乘以1.0001。

一种添加附加值的方式是稍微改变h的衡量单位。如果我们减少衡量单位，那么当我们朝着目标移动的时候f将逐渐增加。很不幸，这意味着A*倾向于扩展到靠近初始点的结点，而不是靠近目标的结点。
我们可以增加衡量单位（甚至是0.1%），A*就会倾向于扩展到靠近目标的结点。

block.txt
........................................
........................................
......O.................................
.....OSO................................
.....O*O................................
.....O*O................................
.....O*O..................#.............
.....O*O..................#.............
.....O*O..................#.............
.....O*O..................#.............
.....O*O..................#.............
.....O*O.##################.............
.....O*O................................
.....O*O................................
.....O*O................................
.....O*OOOOOOOOOOOOOOOOOOOOOOOO.........
.....O*************************E........
......OOOOOOOOOOOOOOOOOOOOOOOOO.........
........................................
........................................

empty.txt
........................................
........................................
......O.................................
.....OSO................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*O................................
.....O*OOOOOOOOOOOOOOOOOOOOOOOO.........
.....O*************************E........
......OOOOOOOOOOOOOOOOOOOOOOOOO.........
........................................
........................................
=============================== case 4 =====================================
struct Node {
    int x, y, dis;
    int g() const { return dis; }
    double h() const { return (abs(x - ex) + abs(y - ey)) * 1.0001; }
    double abs_cross(int x, int y) const {
        return abs((x - sx) * (ey - sy) - (y - sy) * (ex - sx)) * 0.001;
    }
    bool operator<(const Node& o) const {
        if (g() + h() - (o.g() + o.h()) < 1e-15) {
            return abs_cross(x, y) > abs_cross(o.x, o.y);
        }
        return g() + h() > o.g() + o.h();  // priority_queue 默认大根堆
    }
    Node(int _x, int _y, int _dis) : x(_x), y(_y), dis(_dis) {}
};
评估函数 f(x) = g(x) + h(x)
g(x) x节点到起点的距离，
h(x) x节点到目标的曼哈顿距离乘以1.0001 对于多个相同的f(x)，选择最靠近起点与终点的连线的点进行扩展。
block.txt
CCOOO...................................
CCCCCOOOO...............................
OCOCCCOCCOOOOOO.........................
.O.OOOSOOOOOOOOOO.......................
....OC*CCCCCOOCCCOOOOOOOOOOOO...........
.....O*COCCCCCOCCCCCCCCCCCCCCO..........
.....O*OOCCCCCCCOOCCCCCCCO#OCO..........
.....O**OCCCCCCCCCCOOOOOOC#OCO..........
......O*OCCOCCCCCCCCCCCCCC#OCCO.........
......O*OCCOCCCCCCCCOOOOCO#OCCO.........
......O*OCCOCCCCCOCCCCCCCC#OCO..........
......O**##################.O...........
.......O*****************OO.............
........OOOOOOOOOOOOOOOO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................
empty.txt
........................................
........................................
......OO................................
.....OS*OO..............................
......O***OO............................
.......OO***OO..........................
.........OO***OO........................
...........OO***OO......................
.............OO***O.....................
...............OO**OO...................
.................O***OO.................
..................OO***OO...............
....................OO***OO.............
......................OO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................

=============================== case 5 =====================================

struct Node {
    int x, y, dis;
    int g() const { return dis; }
    double h() const { return (abs(x - ex) + abs(y - ey)) * 1.0001; }
    double abs_cross(int x, int y) const {
        return abs((x - sx) * (ey - sy) - (y - sy) * (ex - sx)) * 0.001;
    }
    bool operator<(const Node& o) const {
        if (g() + h() - (o.g() + o.h()) < 1e-9) {
            return abs_cross(x, y) > abs_cross(o.x, o.y);
        }
        return g() + h() > o.g() + o.h();  // priority_queue 默认大根堆
    }
    Node(int _x, int _y, int _dis) : x(_x), y(_y), dis(_dis) {}
};
评估函数 f(x) = g(x) + h(x)
g(x) x节点到起点的距离，
h(x) x节点到目标的曼哈顿距离乘以1.0001 对于多个相同的f(x)，选择最靠近起点与终点的连线的点进行扩展。

block.txt
CCOOO...................................
CCCCCOOOO...............................
OCOCCCOCCOOOOOO.........................
.O.OOOSOOOOOOOOOO.......................
....OC*CCCCCOOCCCOOOOOOOOOOOO...........
.....O*COCCCCCOCCCCCCCCCCCCCCO..........
.....O*OOCCCCCCCOOCCCCCCCO#OCO..........
.....O**OCCCCCCCCCCOOOOOOC#OCO..........
......O*OCCOCCCCCCCCCCCCCC#OCCO.........
......O*OCCOCCCCCCCCOOOOCO#OCCO.........
......O*OCCOCCCCCOCCCCCCCC#OCO..........
......O**##################.O...........
.......O*****************OO.............
........OOOOOOOOOOOOOOOO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................
empty.txt
........................................
........................................
......OO................................
.....OS*OO..............................
......O***OO............................
.......OO***OO..........................
.........OO***OO........................
...........OO***OO......................
.............OO***O.....................
...............OO**OO...................
.................O***OO.................
..................OO***OO...............
....................OO***OO.............
......................OO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................
=============================== case 6 =====================================
struct Node {
    int x, y, dis;
    int g() const { return dis; }
    double h() const { return (abs(x - ex) + abs(y - ey)) * 1.0001; }
    double abs_cross(int x, int y) const {
        return abs((x - sx) * (ey - sy) - (y - sy) * (ex - sx)) * 0.001;
    }
    bool operator<(const Node& o) const {
        if (g() + h() == o.g() + o.h()) {
            return abs_cross(x, y) > abs_cross(o.x, o.y);
        }
        return g() + h() > o.g() + o.h();  // priority_queue 默认大根堆
    }
    Node(int _x, int _y, int _dis) : x(_x), y(_y), dis(_dis) {}
};
empty.txt
........................................
........................................
......OO................................
.....OS*OO..............................
......O***OO............................
.......OO***OO..........................
.........OO***OO........................
...........OO***OO......................
.............OO***O.....................
...............OO**OO...................
.................O***OO.................
..................OO***OO...............
....................OO***OO.............
......................OO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................
block.txt
........................................
........................................
......OO................................
.....OS*OOO.............................
......O*CCCOO...........................
......O*CCCCCOO.........................
......O*OCCCCCCOO.........#.............
......O*OCOCCCCCCOO.......#.............
......O*OCOCOCCCCCCO......#.............
......O*OCOCOCOCCCCCOOOOOO#.............
......O*OCOCOCOCOCCCCCCCCC#.............
......O**##################.............
.......O*****************OO.............
........OOOOOOOOOOOOOOOO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................
=============================== case 7 =====================================
struct Node {
    int x, y, dis;
    int g() const { return dis; }
    double h() const { return (abs(x - ex) + abs(y - ey)) * 1.000; }
    double abs_cross(int x, int y) const {
        return abs((x - sx) * (ey - sy) - (y - sy) * (ex - sx)) * 0.001;
    }
    bool operator<(const Node& o) const {
        if (g() + h() == o.g() + o.h()) {
            return abs_cross(x, y) > abs_cross(o.x, o.y);
        }
        return g() + h() > o.g() + o.h();  // priority_queue 默认大根堆
    }
    Node(int _x, int _y, int _dis) : x(_x), y(_y), dis(_dis) {}
};
block.txt
........................................
........................................
......OOO...............................
.....OS*OOO.............................
.....OO**CCOO...........................
.....OOC*CCCCOO.........................
.....OOC*CCCCCCOO.........#.............
.....OOC*CCCCCCCCOO.......#.............
.....OOC*CCCCCCCCCCO......#.............
.....OOC*CCCCCCCCCCCOOOOOO#.............
.....OOC*CCCCCCCCCCCCCCCCC#.............
......OC*##################.............
.......O*****************OO.............
........OOOOOOOOOOOOOOOO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................
empty.txt
........................................
........................................
......OO................................
.....OS*OO..............................
......O***OO............................
.......OO***OO..........................
.........OO***OO........................
...........OO***OO......................
.............OO***O.....................
...............OO**OO...................
.................O***OO.................
..................OO***OO...............
....................OO***OO.............
......................OO***OO...........
........................OO***OO.........
..........................OO***O........
............................OO*E........
..............................O.........
........................................
........................................
=============================== case 8 =====================================

case 1 和 case 2 比较浮点数对h(x)的影响
case 2 和 case 3 比较添加附加值(增加衡量单位)的h(x)
case 4 5 6 添加附加值以及向量比较的h(x) 在比较f的差异浮点数精度问题