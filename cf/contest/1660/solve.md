# Codeforces Round #780 (Div. 3)
# A
给出a个面值为1的硬币和b个面值为2的硬币。问最小不能表示的大于0的面值。

如果a=0，那么为1
如果b=0，那么为a+1
否则，`b*2+a+1`
试想如果有一个面值为1的硬币，那么面值`b*2`以内都可表示。面值`b*2+a`及以内也能表示。

# B
分别给出n种糖果的数量，每次吃数量最多的种类中的一个，而且每次吃的种类和上次不一样。问能否吃完。

如果最多的种类和次多的种类相差超过1，那么不可能吃完。 否则能吃完。
交替吃最多和次多种类，这样可以降低到与第三多持平，然后在这三中中交替吃。以此类推可以吃完。

# C
给出一个字符串，让你通过删除字符这种操作来让字符串变成‘偶数串’。
偶数串是长度为偶数，且奇数下标i，有$a_i = a_{i+1}$. 下标从1开始。

设`dp[i]`为前i个字符的子串变为偶数串需要删除的最小字符数。
然后用hash表记录字符a在字符串中最近出现的下标j,
若当前位置的下标为i，dp[i]可以由删除j+1到i-1的字符+dp[j-1]贡献；也可由删除当前字符+dp[i-1]贡献。
`j = hash[s[i]]`
`dp[i] = min(dp[i-1]+1, dp[j-1]+i-j-1)`

# D
给出n个数每个数的绝对值不超过2，通过删除一些前缀和后缀使得乘积最大。如果最后删得只剩空串，那么乘积视为1.

模拟。
以0作为分割点，将串分割，然后逐个处理这些子串。 得到子串的最大乘积，并维护所有子串的最大值。

遍历子串并统计负数数量。 如果负数个数是偶数，那么子串的最大乘积就是所有数的乘积；（这里需要注意一点：n的数量级是1e5。如果全部是2，那么无法用基本数据类型表示。可以记录`|a[i]| = 2`的数量。）
如果负数的个数是奇数，那么需要比较第一个负数之后的乘积，和最后一个负数之前的乘积谁更大。
当我们维护最大乘积时，也需要记录对应的左右端点，最后以便计算需要删除多少前后缀。

# E
给出一个`n*n`的01矩阵。每次可以轮转移动一行或一列。
通过任意次轮转操作后，可以使用任意次的反转操作：0变1，1变0，
最后要变成单位矩阵(主对角线全1其他全0)，问最少需要多少次反转操作？

暴力
由于可轮转，所以可认为矩阵有n条主对角线。 枚举这n条主对角线并统计0和1的个数，对于0我们需要反转，而对于非对角线上的1也需要反转，这样就求出每条对角线需要反转的次数了，然后维护最小即可。

# F
给出一个只由`+`和`-`组成的字符串。 如果加号和减号的个数相同那么称之为平衡，另外还有一种操作：两个相邻的减号可以替换成一个加号，问这个字符串有多少平衡的子串？

区间dp超时了。
直接暴力却行。
用双重for可以枚举每个子串，当枚举以l为左端点的串时记录加号个数a，减号个数b，'相邻的'减号个数c。
然后就是判断当前子串是否平衡。
如果我们选择用k个相邻的减号去换成加号使得加号和减号相同，就有`a-2*k=b+k, 0<=k<=c`。
变形有`a-b = 3*k`，也就是说a-b是3的倍数，且倍数不超过c就平衡。当然应该a>=b。
然后统计合法的串的个数输出即可。