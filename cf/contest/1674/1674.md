# Codeforces Round #786 (Div. 3)

# A
给出两个整数 x 和 y, 选择两个整数a，b使得，x* b^a = y

若y/x 除不尽则无法找出。
若能除尽，构造特殊答案让b=y/x, a = 1即可

# B
问在所有两个不同小写字母组成的字符串中，字符串s按字典序排第几。

先看首字符a1贡献at1，(a1-'a') * 25, 再看尾字符a2贡献at2，若a1< a2, 则贡献为(a2-'a')-1;若a1 > a2, 则贡献为(a2-'a');
答案为at1+at2+1

# C
给出一个字符串s只包含小写字母a，另外给出字符串t。每次可以替换s中的某个a为t。问最后有多少中替换可能，无限则为-1.

看t中是否包含a。
若t中包含a： t的长度为1的话，只有一种可能； t的长度不为1，则每次替换s后长度变长，所以是无限种。
若t中不包含a：s中的每个可选择替换或不替换，总共有2^len种。len为s的长度。

# D
给出一个非空数组a，空数组b，空数组c。 
首先，每次可以将a中的最后一个字符放到b的最中间(若b的个数为奇数则可以放到中间的任意两侧)，直到a数组为空为止。
然后，每次可以将b中的中间字符(b为偶数则中间任意两个之一都可选)放到c的尾部，直到b为空为止。

问是否能让c非降序排序。

若n为偶数，将n个数两两连续的分成一组，最后可以分成n/2组。只要保证连续的两组之间前一组最大值小于等于后一组最小值即可。
若n为奇数，则在第一个数前插入0，按偶数处理。

# E
给出一个数组a，代表n座城池的耐久度，每次可以投掷石头，对目标造成2点伤害，此外周边两个会受到1点伤害。问攻破两座城最少要投掷多少石头？

对于间隔超过2座城i和j，对i投掷和对j投掷是独立的。所以一个待选答案是$min(\lfloor \frac{a[i]}{2} \rfloor , \lfloor \frac{a[j]}{2} \rfloor)$。
对于间隔为1座城的i和j，无论对i还是对j投掷都会稳定输出2点伤害，没有浪费。所以待选答案是$\lfloor \frac{(a[i]+a[j]+1)}{2} \rfloor$， 对于总耐久度不是2的倍数需要再投一次。
对于相邻的i和j，设a[i]与b[i]中最大值为x，最小值为y。
我们为了尽可能少投掷，就应当让伤害打满，不要浪费。 先对x投，看是否x和y最后会相等，对耐久度相等的轮流投掷x或y，这样就尽可能少的浪费伤害，进而投掷的次数也就是最少。
设对x投了k次后x和y相等。
那么有x-k* 2 = y - k
可知k = x-y.
此时x和y都变成了2* y - x.
若2* y - x <= 0，从现实意义上想，初始时较小的耐久度不到较大的耐久度一半大。那么一直投掷较大的，待它被摧毁时较小的也跟着毁了。所以待选答案为$\lfloor \frac{x}{2} \rfloor$
若2* y - x > 0, 则考虑轮流投掷，由于总耐久度为2 * (2 * y - x), 每次稳定打出三点伤害，摧毁需要2* (2* y-x)/3次，总共x-y + (4* y - 2 * x)/3 = (x+y)/3次。
需要向上取整。 $\lfloor \frac{x+y}{3} \rfloor$

# F
模拟电脑桌面图标从左到右，从上到下排好，需要多少步。 有q次查询，每次每次都会添加或删除一个图标，然后问排好后需要多少步。

我们将屏幕看作二维数组，从上到下的一列作为二维数组中的一维数组。 然后将二维数组化为一维数组。
假设当前有x个图标，我们只需要知道前x个数中有多少个是空白就是要移动多少步了。 因为最后移动完成后前x个都是图标，而在移动前，前x个中已存在的图标是不用移动的。
每次查询时可以维护当前屏幕上有多少个图标，然后求前缀和即可，但是求q次前缀和可能复杂度过高，可以用树状数组优化。
也可以再维护一个变量作为前x个数中的图标个数。
具体的做法小复杂。注意增加或减少的位置。