# Codeforces Round #782 (Div. 2)
# A
红队和蓝队在打比赛，红队的胜场比蓝队多。
给出比赛场数n，红队胜利场数r，蓝队胜利场数b
请构造红蓝对决的n场比赛结果，要求红队连胜尽可能少

可以将红队胜场分成b+1份，然后用b场蓝队胜利分隔它们。
红队连胜尽量平均，可分为a%(b+1)组连胜a/(b+1)+1场，b+1-a%(b+1)组连胜a/(b+1)场。

# B
给出一个01串，每次操作可以选取一个位置i，除了i以外其他位置都取反。问在k次操作后最大字典序的01串是多少

通过观察发现
当k为奇数时，每次应当反转从左到右原串1出现的位置，因为0在奇数次取反后会变为1，从左到右的顺序是为了字典序最大。设原串的1出现的次数是cnt1，那么在k>cnt1时，cnt1为奇数那么答案为全1，为偶数则除最后一个全1. 在k< cnt1时，在第k个1的位置及之前都是1，后面的数由于奇数次取反，所以整体取反。
当k为偶数时，同理，每次选0的位置。 

# C
给出一个n个城的位置，这些位置是升序排序的。 每次的操作有两种：
征服：每次可以征服离你最近的一座未征服的城市。 需要花费a* |c1-c2|
迁都：每次可以迁移到任意一座你已经征服的城市。 需要花费b* |c1-c2|
c1是你当前的位置，初始为0，c2是目标城市位置
问征服所有城市的最小花费

实际上，当我们迁都到i城市的时候，中间无论是怎样组合的操作。到i城市花费总是pos[i]* (a+b)
这样可以枚举每个城市作为根据点去征服其他城市的花费。然后维护总花费最小即可，注意到当i作为根据地征服后面的城市花费若为cost，那么i-1城市征服之后的城市花费是(n-i)* (pos[i]-pos[i-1]) + cost, 这样我们可以从后向前枚举，并维护后缀和。时间复杂度O(n)

# D
给出一个长度为n的01串s，若s1为给s前1个数排序后的串，s2为给s前2个数排序后的串，si为给s前i个数排序后的串
数组c中元素分别记录s1,s2,...,sn每个位上的和。
初始给出c，构造出s

s中每个1在si中都做出了相同贡献。那么c中元素总和/n便是s中1的个数。设1的个数为k。
若s的最后一个值为1则c的最后一个值必定为n，否则不为n
无论s最后一个数是否为0，我么可以让当前c的后k个数都减少1。 然后舍弃c最后一个元素
在舍弃之前c最后一个数是1，则k应当减少1.
这个区间减少可以用线段树维护，也可以维护一个差分数组并维护一个后缀和。