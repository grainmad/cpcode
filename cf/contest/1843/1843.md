# Codeforces Round 881 (Div. 3)
[Complete problemset](https://codeforces.com/contest/1843/problems)

## [A. Sasha and Array Coloring](https://codeforces.com/contest/1843/problem/A)

### 题意

给一个序列上色，可以上任意种色，然后求序列值，序列值为每种颜色的得分之和。每种颜色的得分之和是所上的元素中的最大值-最小值。

求最大序列值。

### 思路

贪心。

先排序，每种颜色涂两个值，最大值和最小值涂同一种颜色即可。

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto& i : a)
        cin >> i;
    sort(a.begin(), a.end());
    int ans = 0;
    for (int i = 0; i < n / 2; i++) {
        ans += a[n - 1 - i] - a[i];
    }
    cout << ans << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [B. Long Long](https://codeforces.com/contest/1843/problem/B)

### 题意

给出一个序列，每次操作可以使得序列的一个区间中的值变为相反数。

现在求最少次的操作次数，使得序列全为非负数。

### 思路

直接统计非正数的段数就行了。

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto& i : a)
        cin >> i;
    int f = 0, cnt = 0;
    ll ans = 0;
    for (int i : a) {
        if (i < 0 && !f) {
            f = 1;
            cnt++;
        } else if (i > 0 && f) {
            f = 0;
        }
        ans += abs(i);
    }
    cout << ans << " " << cnt << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [C. Sum in Binary Tree](https://codeforces.com/contest/1843/problem/C)

### 题意

给出一个完全二叉树。节点的编号按照层序遍历逐个增大。

问从根节点到n号节点的编号总和是多少。


### 思路

x的父节点是$\lfloor \frac{x}{2} \rfloor$
所以当x非0时，直接累加x到答案中，并重新赋值x为$\lfloor \frac{x}{2} \rfloor$。
时间复杂度$O(logn)$

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    ll n;
    cin >> n;
    ll ans = 0;
    while (n) {
        ans += n;
        n /= 2;
    }
    cout << ans << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [D. Apple Tree](https://codeforces.com/contest/1843/problem/D)

### 题意

给出一颗树，然后有两个果子在树上，每次每个果子会随机移动到当前节点的子节点上。当前节点为叶子节点时则掉落。问有多少种掉落方式。

### 思路

求出每颗子树的叶子节点数，`leaf[i]`为以i节点为根的子树的叶子数。

若果子在x和y节点上，则答案是`leaf[x]*leaf[y]`。

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    int n;
    cin >> n;
    vector<vector<int>> g(n + 1);
    for (int i = 1; i < n; i++) {
        int x, y;
        cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    vector<ll> leaf(n + 1);
    function<ll(int, int)> dfs = [&](int u, int fa) {
        int cnt = 0;
        for (auto v : g[u]) {
            if (v == fa)
                continue;
            cnt++;
            leaf[u] += dfs(v, u);
        }
        if (cnt == 0)
            return leaf[u] = 1;
        return leaf[u];
    };
    dfs(1, 0);
    int q;
    cin >> q;
    for (int i = 0; i < q; i++) {
        int x, y;
        cin >> x >> y;
        cout << leaf[x] * leaf[y] << "\n";
    }
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [E. Tracking Segments](https://codeforces.com/contest/1843/problem/E)

### 题意

初始一个全0数组。

给出m个区间。现在有q次操作。每次操作会让数组中的一个值变为1。

问最少多少次操作使得m个区间中有一个为**美丽区间**。

美丽区间就是1的个数严格大于0的个数。

### 思路

看到最少多少次。二分贪心。

二分一个答案x，那么将前x次操作作用到数组上，然后检查m个区间即可。这里可以花$O(n)$预处理前缀数组，以便$O(1)$检查区间。

总时间复杂度$O(n*m*logq)$

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    int n, m;
    cin >> n >> m;
    vector<pair<int, int>> v(m);
    for (auto& [i, j] : v)
        cin >> i >> j;
    int q;
    cin >> q;
    vector<int> opt(q);
    for (auto& i : opt)
        cin >> i;
    int l = 0, r = q + 1;
    while (l < r) {
        int c = l + r >> 1;
        vector<int> a(n + 1);
        for (int i = 0; i < c; i++)
            a[opt[i]] = 1;
        for (int i = 1; i <= n; i++)
            a[i] += a[i - 1];
        int ok = 0;
        for (auto& [i, j] : v) {
            if (a[j] - a[i - 1] > (j - i + 1) / 2)
                ok = 1;
        }
        if (ok) {
            r = c;
        } else {
            l = c + 1;
        }
    }
    if (r == q + 1) {
        cout << "-1\n";
    } else {
        cout << r << "\n";
    }
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [F1. Omsk Metro (simple version)](https://codeforces.com/contest/1843/problem/F1)

### 题意

有一颗树，根节点编号为1。树的节点有权值-1或1.

有若干次查询，每次查询问节点1到x的路径上是否存在子段和为k。

### 思路

动态规划求树上的最大/小子段和。

假设fx为x的父节点。

$val_x$为x的权值。

$mx_x$为从根节点到x路径上以x为子段一端的最大子段和。$mx_x = max(0,mx_fx)+val_x$

$mn_x$为从根节点到x路径上以x为子段一端的最小子段和。$mn_x = min(0,mn_fx)+val_x$

再分别维护它们的前缀。

$pmx_x = max(mx_x, mx_fx)$

$pmn_x = min(mn_x, mn_fx)$

由于每个节点的权值为-1或1。所以在根到x的路径上一定存在值在$[pmn_x, pmx_x]$的子段和。

我们$O(n)$dp预处理后，每次查询只需要$O(1)$

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

int w[N];
int mx[N], mn[N], pmx[N], pmn[N];
int fa[N];

void sol() {
    int n;
    cin >> n;
    w[1] = mx[1] = mn[1] = pmx[1] = pmn[1] = 1;
    int cur = 2;
    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        if (s == "+") {
            int v, x;
            cin >> v >> x;
            fa[cur] = v;
            w[cur] = x;
            mx[cur] = max(mx[v], 0) + w[cur];
            pmx[cur] = max(mx[cur], pmx[v]);
            mn[cur] = min(mn[v], 0) + w[cur];
            pmn[cur] = min(mn[cur], pmn[v]);
            cur++;
        } else {
            int u, v, k;
            cin >> u >> v >> k;
            if (k == 0 || pmn[v] <= k && k <= pmx[v]) {
                cout << "YES\n";
            } else {
                cout << "NO\n";
            }
        }
    }
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [F2. Omsk Metro (hard version)](https://codeforces.com/contest/1843/problem/F2)

### 题意



### 思路



### 代码

``` cpp


```

