Codeforces Round #776 (Div. 3)
1650
# A
给出一个奇数长度的字符串s，和一个字符c， 每次删除s的两个相邻的字符，问最后得到的字符是否等于c

如果s中存在字符c的左边字符是偶数个，右边字符是偶数个即可。
那么c出现的位置应该在s中奇数位置。c出现的次数可能不止一次。只需判断所有下标为偶数是否存在c。若存在则是YES

# B
给出三个整数 l, r, a。
问在求最大的x/a+x%a, x 范围在l到r的闭区间。x/a为向下取整。

第一个比r小的a的倍数`t = r/a*a`,
若t>l, 则可以在l到r中取到(t-1)/a+(t-1)%a 即`r/a*a-1+a-1`。
否则`r/a+r%a`
但是忽略了一点。即便t>l当a=2时。r/a+r%a可能更大。

# C
首先应该想到选取2n个最小权值的点。
然后按照坐标排序。然后双指针成对输出。输出的不是坐标值，而是坐标值对应在输入时的位置。所以需要把坐标映射到输入的位置。

# D
逆向思维
在轮转前n个时把第n个的位置归位。再轮转前n-1个，把第n-1个归位。
n的大小不过几千。模拟完全足够。
这里有种省空间的方法。将所有值都减一。让值的范围变为0到n-1
用一个数组mp记录当前每个值的当前下标。下标在一轮轮转后，若需要归位的是i，i的当前下标`mp[i]`,下标应为i。轮转的数是0到i共i+1个。所以0到i的数应该向左偏移(mp[i]-i+i+1)%(i+1)。 然后将偏移数存入栈中。全部轮转归位后。出栈输出。
这里思路都有了，但是debug的时间过长。 一开始没有考虑所有值-1。 后面没有入栈出栈输出。 还一直在找别的地方的bug。