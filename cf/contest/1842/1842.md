# CodeTON Round 5 (Div. 1 + Div. 2, Rated, Prizes!)
[Complete problemset](https://codeforces.com/contest/1842/problems)

## [A. Tenzing and Tsondu](https://codeforces.com/contest/1842/problem/A)

### 题意

现在有两个人在玩卡牌游戏，一个人有n个怪物，其属性值为$a_1, a_2, \cdots, a_n$，另一个人有m个怪物，其属性分别为$b_1, b_2, \cdots, b_m$。

现在双方每次可以自己的卡牌中选出x和y。让x变为x-y，让y变为y-x，当值小于等于0时则死亡。

当一方没有卡牌则失败，问最后谁会获胜。

### 思路

实际上比的是谁的总属性值最大。

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353

using namespace std;

void sol() {
    int n, m;
    cin >> n >> m;
    ll a = 0, b = 0;
    for (int i = 0; i < n; i++) {
        ll x;
        cin >> x;
        a += x;
    }
    for (int i = 0; i < m; i++) {
        ll x;
        cin >> x;
        b += x;
    }
    if (a > b) {
        cout << "Tsondu\n";
    } else if (a < b) {
        cout << "Tenzing\n";
    } else {
        cout << "Draw\n";
    }
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [B. Tenzing and Books](https://codeforces.com/contest/1842/problem/B)

### 题意

给出三个栈，问能否选取一些数使得或值为x。

### 思路

每个栈我们都选取栈顶尽可能多的数，只要其或值二进制位都是x的子集即可。

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353

using namespace std;

bool check(ll a, ll b) {
    for (int i = 0; i < 32; i++) {
        if ((a >> i & 1) && !(b >> i & 1))
            return false;
    }
    return true;
}

void sol() {
    ll n, x;
    cin >> n >> x;
    ll c = 0;
    for (int _ = 0; _ < 3; _++) {
        int b = 0;
        for (int i = 0; i < n; i++) {
            ll v;
            cin >> v;
            if (b)
                continue;
            if (check(v | c, x))
                c |= v;
            else
                b = 1;
        }
    }
    cout << (c == x ? "YES\n" : "NO\n");
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [C. Tenzing and Balls](https://codeforces.com/contest/1842/problem/C)

### 题意

给出n个排成一排的球，球有不同颜色，每次选取两个相同颜色的球，然后将这两个球以及之间的球都移除掉。

问最多能移除多少球。

### 思路

动态规划

$f_{i}$为前i个球最多能移除的个数。初始$f_0=0$

设$a_j$为最大的j且满足$a_j = a_i, j < i$的数。

$f_{i} = \max (f_{i-1}, f_{j}+i-j, f_{j-1}+i-j+1)$


### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353

using namespace std;

void sol() {
    int n;
    cin >> n;
    vector<int> c(n + 1, -1), f(n + 1);
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        f[i] = f[i - 1];
        if (c[x] != -1)
            f[i] = max({f[i], f[c[x]] + i - c[x], f[c[x] - 1] + i - c[x] + 1});
        c[x] = i;
        // cout << f[i] << " ";
    }
    cout << f[n] << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [D. Tenzing and His Animal Friends ](https://codeforces.com/contest/1842/problem/D)

### 题意

现在有1到n共n个数。每次操作可以选择一个集合，集合中不包含n一定包含1，同时选择一个操作时间t。

然后有m个限制条件。每个限制u，v，w表示u和v恰好只有一个出现在集合中的时间不超过w。

构造满足限制条件的最长时间的操作。

### 思路

差分约束

将限制条件u,v,w看作点u与点v之间的构建一条权值为w的无向边。

然后求出任意两点间的最短路。

我们将所有点按照离n的距离由小到大的顺序排序。

刚开始时集合包含1到n。然后每次从集合中移除一个离n最近的点x，如果下一个离n最近的点是y。那么操作时间是y与n的距离减x与n的距离。当1被移除则终止。

### 代码

``` cpp
#include <bits/stdc++.h>
#define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

ll f[105][105];

void sol() {
    int n, m;
    cin >> n >> m;

    memset(f, 0x3f, sizeof(f));
    for (int i = 0; i < n; i++)
        f[i][i] = 0;
    for (int i = 0; i < m; i++) {
        ll x, y, k;
        cin >> x >> y >> k;
        f[x][y] = f[y][x] = min(f[x][y], k);
    }

    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
            }
        }
    }
    if (f[1][n] > 1e18) {
        cout << "inf\n";
        return;
    }
    vector<pair<string, ll>> ans;
    vector<pair<ll, ll>> v;
    for (int i = 1; i < n; i++) {
        v.emplace_back(min(f[1][n], f[i][n]), i);
    }
    sort(v.begin(), v.end());
    ll pre = 0;
    for (int i = 0; i < v.size(); i++) {
        auto [x, y] = v[i];
        ll dif = x - pre;
        pre = x;
        if (dif == 0)
            continue;
        string s(n, '0');
        for (int j = i; j < v.size(); j++) {
            s[v[j].second - 1] = '1';
        }
        ans.emplace_back(s, dif);
    }
    cout << f[1][n] << " " << ans.size() << "\n";
    for (auto& [i, j] : ans) {
        cout << i << " " << j << "\n";
    }
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}

```

## [E. Tenzing and Triangle](https://codeforces.com/contest/1842/problem/E)

### 题意



### 思路



### 代码

``` cpp

```

## [F. Tenzing and Tree](https://codeforces.com/contest/1842/problem/F)

### 题意

一棵树有n个点，考虑给k个点涂色，涂完色后每条边的代价是这条边所连接的两个连通块的黑点个数之差的绝对值。一颗树的代价是所有边的代价之和。

现在求$0 \le k \le n$的每种情况的最大代价。

### 思路

黑色节点聚在一团会让代价最大。

假设这一团黑色节点共有k个，且重心节点为u。

以u作为根，其余非根节点i的子树中的黑色节点为$size_i$。由于u为重心，$size_i<k/2$

于是代价可表示为$\sum \limits_{i\ne u} (k-2*size_i) = k\times (n-1) - 2\times \sum \limits_{i \ne u} size_i$

可见当我们选取一个节点作为根，其子树的黑色节点越小树的代价就越大。

我们可以枚举每个点作为根，并通过层序遍历逐个添加黑色节点，维护根始终成为所有黑色节点的重心。

当我们添加一个点x作为黑色节点时。x到根节点路径上的所有节点t（不含根节点），$size_t$都会增加1。根据公式$size_t$增加1，树的代价会减少2。因此树的代价会减少2倍x到根所经过的边数。

我们维护$c_i$为涂i个黑色节点的子树黑色节点最小和。那么$(n-1)i-c_i$就是涂i个节点的最大树代价。


### 代码

``` cpp
#include <bits/stdc++.h>
#define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 5005
#define MOD 998244353
using namespace std;

vector<int> g[N];

void sol() {
    ll n;
    cin >> n;
    for (int i = 1; i < n; i++) {
        int x, y;
        cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    ll c[N];
    memset(c, 0x3f, sizeof(c));
    c[0] = 0;
    for (int i = 1; i <= n; i++) {
        vector<ll> deep(n + 1, -1);
        deep[i] = 0;
        queue<int> q;
        q.push(i);
        ll s = 0;
        for (int j = 1; j <= n; j++) {
            int u = q.front();
            q.pop();
            s += deep[u] * 2;
            c[j] = min(c[j], s);
            for (int v : g[u]) {
                if (deep[v] == -1) {
                    deep[v] = deep[u] + 1;
                    q.push(v);
                }
            }
        }
    }
    for (int i = 0; i <= n; i++) {
        cout << i * (n - 1) - c[i] << " ";
    }
    cout << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [G. Tenzing and Random Operations](https://codeforces.com/contest/1842/problem/G)

### 题意



### 思路



### 代码

``` cpp

```

## [H. Tenzing and Random Real Numbers](https://codeforces.com/contest/1842/problem/H)

### 题意



### 思路



### 代码

``` cpp

```

## [I. Tenzing and Necklace](https://codeforces.com/contest/1842/problem/I)

### 题意



### 思路



### 代码

``` cpp

```

