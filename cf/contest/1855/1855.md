# Codeforces Round 889 (Div. 2)
[Complete problemset](https://codeforces.com/contest/1855/problems)

## [A. Dalton the Teacher](https://codeforces.com/contest/1855/problem/A)

### 题意

给出n个椅子，编号为1到n，然后有n个人，编号也是1到n。

给出$p_1,p_2,\cdots,p_n$，代表编号为i的人坐在$p_i$上。

现在每次操作可以任意交换两个的位置，问最少交换多少次可以使得每个人的编号不等于椅子编号。

### 思路

对于编号已经不对应的可以不用管。

交换一次可以减少两个，如果是奇数个则，最后三个需要交换两次。

所以答案就是编号已经不对应的个数除以2向上取整。

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

int a[N];

void sol() {
    int n;
    cin >> n;
    int c = 0;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        if (x == i)
            c++;
    }
    cout << max(0, (c + 1) / 2) << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [B. Longest Divisors Interval](https://codeforces.com/contest/1855/problem/B)

### 题意

给出n，求最大长度的区间`[l,r]`，满足区间整数都是n的因子。

$n\le 10^{18}$

### 思路

最大长度是x，x+1是从小到达第一个不能整除n的数.

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    ll n;
    cin >> n;
    int p = 0, ans = 0;
    for (int i = 1; i < 1000; i++) {
        if (n % i) {
            ans = max(i - p - 1, ans);
            p = i;
        }
    }
    cout << ans << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [C1. Dual (Easy Version)](https://codeforces.com/contest/1855/problem/C1)

### 题意

给出一个数组$a_1, a_2, \codts, a_n$,每次操作可以选择两个位置i和j让$a_i = a_i+a_j$

构造不超过50次的操作序列使得a不递减

$-20 \le a_i\le 20$

$1\le n \le 20$

### 思路

对于全为正整数,我们可以i从2到n依次执行$a_i = a_i + a_{i-1}$, 最后得到非递减序列. 不超过20次

对于全为负整数,我们可以i从n-1到1依次执行$a_i = a_i + a_{i+1}$, 最后得到非递减序列. 不超过20次

最后如果存在正数和负数, 那么我们可以让整个数组变为负数或正数,所花操作不超过20次.

所以50次是可以轻松达到目标的

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int& i : a)
        cin >> i;
    int mx = *max_element(a.begin(), a.end());
    int mn = *min_element(a.begin(), a.end());
    if (mx >= 0 && mn >= 0) {
        cout << n - 1 << "\n";
        for (int i = 2; i <= n; i++) {
            cout << i << " " << i - 1 << endl;
        }
    } else if (mx <= 0 && mn <= 0) {
        cout << n - 1 << "\n";
        for (int i = n - 1; i >= 1; i--) {
            cout << i << " " << i + 1 << endl;
        }
    } else if (mx > -mn) {
        int p = 0;
        for (int i = 0; i < n; i++)
            if (a[i] == mx)
                p = i;
        p++;
        cout << 2 * n - 2 << "\n";
        for (int i = 1; i <= n; i++) {
            if (i == p)
                continue;
            cout << i << " " << p << "\n";
        }
        for (int i = 2; i <= n; i++) {
            cout << i << " " << i - 1 << endl;
        }
    } else {
        int p = 0;
        for (int i = 0; i < n; i++)
            if (a[i] == mn)
                p = i;
        p++;
        cout << 2 * n - 2 << "\n";
        for (int i = 1; i <= n; i++) {
            if (i == p)
                continue;
            cout << i << " " << p << "\n";
        }
        for (int i = n - 1; i >= 1; i--) {
            cout << i << " " << i + 1 << endl;
        }
    }
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [C2. Dual (Hard Version)](https://codeforces.com/contest/1855/problem/C2)

### 题意



### 思路



### 代码

``` cpp

```

## [D. Earn or Unlock](https://codeforces.com/contest/1855/problem/D)

### 题意



### 思路



### 代码

``` cpp


```

## [E. Expected Destruction](https://codeforces.com/contest/1855/problem/E)

### 题意



### 思路



### 代码

``` cpp


```

## [F. Michael and Hotel](https://codeforces.com/contest/1855/problem/F)

### 题意



### 思路



### 代码

``` cpp


```

