# Codeforces Round 917 (Div. 2)
[Complete problemset](https://codeforces.com/contest/1917/problems)

## [A. Least Product](https://codeforces.com/contest/1917/problem/A)

### 题意

给你一个整数数组 $a_1, a_2, \dots, a_n$ 。您可以执行以下操作任意次数（可能为零）：

- 从数组中任选一个元素 $a_i$ ，将其值改为 $0$ 和 $a_i$ （含）之间的任意整数。更正式地说，如果是 $a_i > 0$ ，则将 $a_i$ 替换为 $[a_i, 0]$ 中的任意整数，否则将 $a_i$ 替换为 $[0, a_i]$ 中的任意整数。

假设 $r$ 是执行任意次数运算后所有 $a_i$ 的最小乘积。

求使乘积等于 $r$ 所需的最小运算次数。同时，请打印这样一个最短的运算序列。如果有多个答案，可以打印任意一个。

每个测试由多个测试用例组成。第一行包含一个整数 $t$ ( $1 \leq t \leq 500$ ) 测试用例的数量。随后是测试用例说明。

每个测试用例的第一行包含一个整数 $n$ ( $1 \leq n \leq 100$ ) 数组的长度。

每个测试用例的第二行包含 $n$ 个整数 $a_1, a_2, \ldots, a_n$ ( $-10^9 \leq a_i \leq 10^9$ ).

### 思路

看负数出现个数的奇偶性。

如果是偶数个负数，那么任选一个数为0，否则无需更改。


### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    int n;
    cin >> n;
    int neg = 0, zero = 0;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        if (x < 0)
            neg++;
        if (x == 0)
            zero++;
    }
    if (neg % 2 || zero) {
        cout << "0\n";
    } else {
        cout << "1\n1 0\n";
    }
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [B. Erase First or Second Letter](https://codeforces.com/contest/1917/problem/B)

### 题意

给你一个长度为 $n$ 的字符串 $s$ 。让我们定义一下可以对字符串进行的两种操作：

- 删除字符串的第一个字符；
- 删除字符串的第二个字符。

你的任务是找出对初始字符串进行任意次数（可能为零）、任意顺序的操作后，可以生成的**非空**字符串的个数。


每个测试由多个测试用例组成。第一行包含一个整数 $t$ ( $1 \leq t \leq 10^4$ ) - 测试用例的个数。测试用例说明如下。

每个测试用例的第一行包含 $n$ ( $1 \leq n \leq 10^5$ ) - 字符串长度。

每个测试用例的第二行包含字符串 $s$ 。保证字符串只包含小写英文字母。

保证所有测试用例的 $n$ 之和不超过 $2 \cdot 10^5$ 。

### 思路

对于这个字符串中的任意一个字符，我们可以删除这个字符前面的前缀，以及这个字符后面若干字符，形成一个新的字符串。

形成的新字符串会有重复，我们需要去重。

考虑所有后缀会形成多少个不同的字符串。对于每个后缀，我们看前方的字符种数，如果有k种，那么这个后缀就会形成k个不同的字符串。


### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    int n;
    cin >> n;
    string s;
    cin >> s;
    vector<int> c(256), d(n);
    int cnt = 0;
    ll ans = 0;
    for (int i = 0; i < n; i++) {
        if (c[s[i]]++ == 0)
            cnt++;
        d[i] = cnt;
        ans += d[i];
        // cout << d[i] << ", ";
    }
    cout << ans << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [C. Watering an Array](https://codeforces.com/contest/1917/problem/C)

### 题意

你有一个长度为 $n$ 的整数数组 $a_1, a_2, \ldots, a_n$ 。在接下来 $d$ 天中的 $i$ /th，你要做以下两个操作中的一个：

- 在数组 $a$ 的前 $b_i$ 个元素中的每个元素上添加 $1$ （即每个 $1 \le j \le b_i$ 设置 $a_j := a_j + 1$ ）。
- 计数与其位置相等的元素（即 $a_j = j$ ）。将此类元素的个数记为 $c$ 。然后将 $c$ 加到你的分数中，并将整个数组 $a$ 重置为长度为 $n$ 的 $0$ /数组（即设置 $[a_1, a_2, \ldots, a_n] := [0, 0, \ldots, 0]$ ）。

你的分数一开始等于 $0$ 。请注意，在每一天中，您都应该执行上述操作中的一个：您不能跳过一天或在同一天中同时执行两个操作。

最后您能得到的最高分是多少？

由于 $d$ 可能相当大，所以序列 $b$ 是以压缩格式给出的：

- 给你一个整数序列 $v_1, v_2, \ldots, v_k$ 。序列 $b$ 是无限多份 $v$ 的连接： $b = [v_1, v_2, \ldots, v_k, v_1, v_2, \ldots, v_k, \ldots]$ .


第一行包含一个整数 $t$ ( $1 \le t \le 10^3$ ) - 测试用例的数量。

每个测试用例的第一行包含三个整数 $n$ 、 $k$ 和 $d$ （ $1 \le n \le 2000$ 、 $1 \le k \le 10^5$ 、 $k \le d \le 10^9$ ）--数组的长度 $a$ 、序列的长度 $v$ 以及要执行操作的天数。

每个测试用例的第二行包含 $n$ 个整数 $a_1, a_2, \ldots, a_n$ （ $0 \le a_i \le n$ ）--数组 $0 \le a_i \le n$ 的长度。( $0 \le a_i \le n$ ) -数组 $a$ 。

每个测试用例的第三行包含 $k$ 个整数 $v_1, v_2, \ldots, v_k$ ( $1 \le v_i \le n$ ) - 序列 $v$ 。

保证所有测试用例中 $n$ 的总和不超过 $2000$ ，所有测试用例中 $k$ 的总和不超过 $10^5$ 。

### 思路

对于全为0的数组，我们无论操作多少次第一种操作，最后操作二操作得到的分数还是1。所以最优操作时用两次操作来得到分数1。

也就是说在第一次二操作前，我们可以枚举使用一操作的次数。
一旦第一次二操作后，数组全为0，我们可以O(1)得到剩余操作的最大分数。

最大连续2n天操作一。因为得到的分数不会超过n，一旦超过2n，则可以交替一二操作得到更大的分数。

### 代码

``` cpp
#include <bits/stdc++.h>
// #define SINGLE_INPUT
#define ull unsigned long long
#define ll long long
#define N 500005
#define MOD 998244353
using namespace std;

void sol() {
    ll n, k, d;
    cin >> n >> k >> d;
    vector<int> a(n + 1), v(k);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        a[i] -= i;
    }
    for (auto& i : v)
        cin >> i;
    ll ans = count(a.begin() + 1, a.end(), 0) + (d - 1) / 2;
    // cout << n << " --- " << endl;
    // cout << count(a.begin() + 1, a.end(), 0) << endl;
    for (int i = 0; i < 2 * n; i++) {
        for (int j = 1; j <= v[i % k]; j++) {
            a[j]++;
        }
        if (d - 2 - i >= 0)
            ans = max(ans, count(a.begin() + 1, a.end(), 0) + (d - 2 - i) / 2);
    }
    cout << ans << "\n";
}

int main() {
    cout << setprecision(15) << fixed;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifndef SINGLE_INPUT
    int t;
    cin >> t;
    while (t--) {
        sol();
    }
#else
    sol();
#endif
    return 0;
}
```

## [D. Yet Another Inversions Problem](https://codeforces.com/contest/1917/problem/D)

### 题意



### 思路



### 代码

``` cpp


```

## [E. Construct Matrix](https://codeforces.com/contest/1917/problem/E)

### 题意



### 思路



### 代码

``` cpp


```

## [F. Construct Tree](https://codeforces.com/contest/1917/problem/F)

### 题意



### 思路



### 代码

``` cpp


```

