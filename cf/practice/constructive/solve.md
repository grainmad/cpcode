# 1538B

给出n和m行三元组a,b,c，保证节点a和c之间不能有b，输出n-1行二元组a,b代表a和b之间有一条边。
由于 m < n 所以在三元组中b没有出现的节点每个其他节点都可以连接它，这样就保证是正确的答案
# 1579D
每次用最大值减去最小值就可以得到答案
用set存储二元组值与下标，可实现
# 1527B1
给出一个01回文串，Alice和Bob轮流对回文串执行以下两种操作中的一种：
选择一个0变为1，花费1刀
反转串，只有上次操作不是反转且当前是非回文串，花费0刀
最开始Alice先执行。
最后谁花的钱最少谁赢。

对于0的个数是偶数.
若a先执行，b必赢：a放完后，b放a对称位置，此时仍为回文，a只能继续放，b继续跟，直到只剩下一个0时b选择反转，这是a花的钱会比b多2
对于0的个数是奇数. 有一个0在中心，
a选完中心后，问题转换为上一种情况，先行者为b，最终导致b花的钱比a多2。但是由于a选了中心，所以b花的钱任然比a多1. a赢。 除了只有一个0的情况。

# 1614C

# 1611D. Weights Assignment For Tree Edges
给出序列b，p。 `b[i]`代表i的父节点。 p是按照到根节点的距离排序的节点。 `p[i-1]`比`p[i]`要离根节点更近。
求w， `w[i]`是i号节点与i的父亲节点`b[i]`的距离。

设`dis[i]` 为i到根节点的距离。那么`dis[p[i]] > dis[p[i-1]]`, `p[1]`为根节点，所以`dis[p[1]]=0`。由于i的父节点到根节点的距离必定小于i到根节点的距离。在遍历p时，当前节点的父节点的dis一定有值。否则无解。
最后我们得到了每个节点到根节点的距离。只要输出当前节点到根节点的距离-当前父节点到根的距离，就可以得到当前节点到父亲节点的距离。

# 1603B - Moderate Modular Mode
给出两个偶数x, y 。 求n使得n % x = y % n

当x > y 时，令n = x + y。 
当 x <= y 时，y和x是偶数，令y=k * x+b。 b是偶数且小于x。
n = y-b/2 满足 n%x = b/2 = y%n 。

# 1691C
给出01串，串的权值为两两相邻的字符看为十进制之和. 
For example, for the string s=1011:
d1=10 (ten);
d2=01 (one)
d3=11 (eleven);
f(s)=10+01+11=22.
最多k次操作，每次可以交换相邻字符串，问最小权值。

一个误区就是相邻的1权值更大。其实不然。两个1无论中间有没有0，每个1的贡献都是11.
除非有1在字符串的两端。 在左端则减少贡献1。在右端则减少贡献10.

# 1682C
给出一个数组，在重组之后使得最长上升子序列长度与最长下降子序列长度的最小值最大。

lis和lds最多只会有一个公共点。对于多次出现的点可以分配2个到lis和lds中，其余单次出现的点平均分配到lis和lds即可。若为奇数则作为公共点。

# 1517C
给出1到n的排列a，将一个n* n 的矩阵下三角填充。 形成n个连通区域，第i个区域的格子值为a[i],且(i,i)一定属于第i个区域，相同区域的数属于同一个连通区，第i个连通区域包含i个格子。如果不能填充输出-1.

实际上一定能填充完成。因为1到n每个数只会出现一次。对于第i个区域，先填充(i,i)。然后优先填充左边的格子。其次填充下方格子。

# 417C
有n支队伍相互之间打比赛，每两支队伍最多打一场。 最后每个队伍都赢了k场。构造出一种比赛情况。

由于n支队伍最多打n*(n-1)/2场，平均分每支队伍最多赢(n-1)/2场，k>(n-1)/2则无解。 否则可以构造每支队伍战胜编号顺序下k支队伍。
输出过多endl会超时。

# 1473C

给出n,k, 代表一个长度为n的数组a，后n-k个关于第k对称。 k<=n<2* k ,如n=4，k=3， 1 2 3 2。
构造一个长度为k排列p和长度为n的数组b，其中b[i] = p[a[i]], 使得b的逆序数小于等于a的情况下，b的字典序最大。求p。

若构造的p为p1,p2,...,pk. 则b为p1,p2,...,pk,p(k-1),...,p(2* k-n)。
实际上，每个数不超过2的奇数长度的回文数组逆序数是确定的。
若数组形如a1，a2, ... , ak, ..., a2, a1。 可将相同的数分为一组，共分为k组，其中一组只有一个数ak, 其余都是两个数。 任意两个组之间的逆序数都是2或1，（两个都是包含两个数的组，只包含一个数的组和包含两个数的组）。
所以逆序数为 $2*C_{k-1}^{2}+(k-1) = (k-1)^2$
所以构造p为升序排列，然后将最后n-k+1个数反转，即可让b的字典序最大。且逆序数与a相同。

# 1439A2
给出n * m 的01数组。 每次操作只能从2 * 2 的子数组中选择3个反转值。 构造最后全为0数组的操作过程，且总操作次数不超过m * n。

一次操作可将1* 2的子数组变为0，用(n+1)/2 * (m-2)次可将n * (m-2)的矩阵变为0，再用n-2次将 (n-2) * 2的矩阵变为0，最后2 * 2的矩阵最多用4次可转变为0.
总次数(n+1) * (m-2) / 2 + n-2 + 4 = (n+1)/2* m + 1 <= n* m, 


# 282C
给出两个01串，可以在01，10，11三者中任意转化。问最后是否能让两个串相等。

实际上如果存在1个1，那么可以生成多段1，每段1由多个连续的1组成，段与段之间存在多个连续的0.
这样答案就是两个串都存在或都不存在1则可以转化。 长度不同不能转化。